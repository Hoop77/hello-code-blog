<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Asynchronous network programming in C&#43;&#43; made easy.">
    <meta name="author" content="Philipp Badenhoop">
    <meta name="keywords" content="">


    <title>An Introduction to asionet -- The computer science blog.</title>

    

    
    <link href="https://hellocodeblog.com/css/bootstrap.min.css" rel="stylesheet">

    
    <link href="https://hellocodeblog.com/css/hello-code-blog.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,900" rel="stylesheet"> 

    
    
    

</head>

<body>

    
    <nav class="navbar navbar-expand-md navbar-custom">
        <a class="navbar-brand" href="https://hellocodeblog.com">hello {code} blog</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span><i class="fa fa-bars"></i></span>
        </button>
                   
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ml-auto">
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://hellocodeblog.com/">Home</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://hellocodeblog.com/post/">Archive</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://hellocodeblog.com/about/">About</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="https://hellocodeblog.com/contact/">Contact</a>
                    </li>
                    
                  </ul>
            </div>
           

    </nav>


    
    
    <header class="intro-header">
    
      <div class="container">
        <div class="row">
           <div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1">
             <div class="post-heading">
                <h1>An Introduction to asionet</h1>
                <div class="subheading syntax-color-comment">
                  Asynchronous network programming in C&#43;&#43; made easy.
                </div>
                <div class="meta">
                  <span class="syntax-color-doc">
  
  /** <br />
  &nbsp;* <span class="syntax-color-highlight">\author</span> Philipp Badenhoop
  <br />
  &nbsp;* <span class="syntax-color-highlight">\date</span> <span>Tue, Jan 8, 2019</span>
  <br />
  &nbsp;* <span class="syntax-color-highlight">\tags</span> <span><a href="https://hellocodeblog.com/tags/c&#43;&#43;" class="syntax-color-doc">c&#43;&#43;</a>, <a href="https://hellocodeblog.com/tags/network" class="syntax-color-doc">network</a>, <a href="https://hellocodeblog.com/tags/boost" class="syntax-color-doc">boost</a>, <a href="https://hellocodeblog.com/tags/asionet" class="syntax-color-doc">asionet</a></span>
  <br />
  &nbsp;*/
</span>
                </div>
             </div>
           </div>
        </div>
      </div>
    </header>

    
    <article>
        <div class="container">
              

<h1 id="introduction">Introduction</h1>

<p>In case you&rsquo;ve ever done some network programming in C++, you probably stumbled upon the quasi-standard boost::asio library.
It uses asynchronous programming making it scalable but on the other side, it takes quite some time to learn how to use it correctly.<br />
<strong>asionet</strong> is built on top of boost::asio which makes it 100% compatible with it but easier to use at the same time.
For example, managing timeouts and sending and receiving serialized messages is done with only a few lines of code.</p>

<p><a href="https://github.com/Badenhoop/asionet">Here</a> is the link to the github repository.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>In order to use the library, you have to compile with the C++14 standard and make sure to include Boost 1.66 and your system&rsquo;s thread library in your project.
In your CMakeLists.txt, insert:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>set(<span style="color:#48b685">CMAKE_CXX_STANDARD</span> <span style="color:#48b685">14</span>)<span style="color:#ef6155">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span><span style="color:#ef6155"></span>find_package(<span style="color:#48b685">Boost</span> <span style="color:#48b685">REQUIRED</span> <span style="color:#48b685">COMPONENTS</span> <span style="color:#48b685">system</span> <span style="color:#48b685">regex</span>)<span style="color:#ef6155">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span><span style="color:#ef6155"></span>find_package(<span style="color:#48b685">Threads</span>)<span style="color:#ef6155">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span><span style="color:#ef6155"></span>link_libraries(<span style="color:#5bc4bf">${</span><span style="color:#ef6155">Boost_LIBRARIES</span><span style="color:#5bc4bf">}</span> <span style="color:#5bc4bf">${</span><span style="color:#ef6155">CMAKE_THREAD_LIBS_INIT</span><span style="color:#5bc4bf">}</span>)</code></pre></div>

<h2 id="installation">Installation</h2>

<p>Get the repository, build and install it.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>$ git clone https://github.com/Badenhoop/asionet
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>$ cd asionet
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>$ mkdir build
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>$ cd build
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>$ cmake ..
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>$ sudo make install</code></pre></div>

<h2 id="usage">Usage</h2>

<p>Just insert the following into your CMakeLists.txt file:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>find_package(<span style="color:#48b685">asionet</span>)<span style="color:#ef6155">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span><span style="color:#ef6155"></span>link_libraries(<span style="color:#48b685">asionet</span>)</code></pre></div>

<h1 id="tutorial">Tutorial</h1>

<h2 id="receiving-string-messages-over-udp">Receiving string messages over UDP</h2>

<p>The code below listens to port 4242 for receiving a UDP datagram with timeout 1 second.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span><span style="color:#776e71">// Just a typedef of boost::asio::io_context (aka io_service).
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#776e71">// A thread which runs the context object and dispatches asynchronous handlers.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>Worker worker{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span><span style="color:#776e71">// UDP datagram receiver operating on port 4242.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>DatagramReceiver<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span> receiver{context, <span style="color:#f99b15">4242</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span><span style="color:#776e71">// Receive a string message with timeout 1 second.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span><span style="color:#776e71"></span>receiver.asyncReceive(<span style="color:#f99b15">1</span>s, [](<span style="color:#815ba4">const</span> asionet<span style="color:#5bc4bf">::</span>error<span style="color:#5bc4bf">::</span>Error <span style="color:#5bc4bf">&amp;</span> error, 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>                             std<span style="color:#5bc4bf">::</span>string <span style="color:#5bc4bf">&amp;</span> message,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>                             <span style="color:#815ba4">const</span> boost<span style="color:#5bc4bf">::</span>asio<span style="color:#5bc4bf">::</span>ip<span style="color:#5bc4bf">::</span>udp<span style="color:#5bc4bf">::</span>endpoint <span style="color:#5bc4bf">&amp;</span> senderEndpoint) 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span>    <span style="color:#815ba4">if</span> (error) <span style="color:#815ba4">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span>    std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;received: &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> message <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span>              <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;host: &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> senderEndpoint.address().to_string() <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span>              <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;port: &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> senderEndpoint.port() <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span>; 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">16</span>});
</code></pre></div>

<h2 id="sending-string-messages-over-udp">Sending string messages over UDP</h2>

<p>The following code sends a UDP message containing the string &ldquo;Hello World!&rdquo; to IP 127.0.0.1 port 4242 with operation timeout 10ms.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>DatagramSender<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span> sender{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>sender.asyncSend(<span style="color:#48b685">&#34;Hello World!&#34;</span>, <span style="color:#48b685">&#34;127.0.0.1&#34;</span>, <span style="color:#f99b15">4242</span>, <span style="color:#f99b15">10</span>ms);
</code></pre></div>

<h2 id="defining-custom-messages">Defining custom messages</h2>

<p>Wouldn&rsquo;t it be nice to just send your own data types as messages over the network?
Let&rsquo;s assume we want to program the client for an online game so we have to send updates about our player&rsquo;s state.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span><span style="color:#815ba4">struct</span> PlayerState
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>    std<span style="color:#5bc4bf">::</span>string name;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>    <span style="color:#fec418">float</span> posX;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>    <span style="color:#fec418">float</span> posY;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>    <span style="color:#fec418">float</span> health;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>};
</code></pre></div>

<p>Now we could replace the template parameter from std::string with PlayerState to tell DatagramSender to send PlayerState objects:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>DatagramSender<span style="color:#5bc4bf">&lt;</span>PlayerState<span style="color:#5bc4bf">&gt;</span> sender{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>PlayerState playerState{<span style="color:#48b685">&#34;WhatAPlayer&#34;</span>, <span style="color:#f99b15">0.15f</span>, <span style="color:#f99b15">1.7f</span>, <span style="color:#f99b15">0.1f</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>sender.asyncSend(playerState, <span style="color:#48b685">&#34;127.0.0.1&#34;</span>, <span style="color:#f99b15">4242</span>, <span style="color:#f99b15">10</span>ms);
</code></pre></div>

<p>The only thing for that to work is to tell asionet how to serialize a PlayerState object into a string of bytes which is simply represented as a string.
Therefore, we could just use the nlohmann json library which is an amazing piece of work by the way.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span><span style="color:#815ba4">namespace</span> asionet { <span style="color:#815ba4">namespace</span> message {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#815ba4">template</span><span style="color:#5bc4bf">&lt;&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span><span style="color:#815ba4">struct</span> Encoder<span style="color:#5bc4bf">&lt;</span>PlayerState<span style="color:#5bc4bf">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>    <span style="color:#fec418">void</span> <span style="color:#815ba4">operator</span>()(<span style="color:#815ba4">const</span> PlayerState <span style="color:#5bc4bf">&amp;</span> playerState, std<span style="color:#5bc4bf">::</span>string <span style="color:#5bc4bf">&amp;</span> data) <span style="color:#815ba4">const</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span>        <span style="color:#815ba4">auto</span> j <span style="color:#5bc4bf">=</span> nlohmann<span style="color:#5bc4bf">::</span>json{ {<span style="color:#48b685">&#34;name&#34;</span>, playerState.name },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>                                 {<span style="color:#48b685">&#34;xPos&#34;</span>, playerState.xPos },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>                                 {<span style="color:#48b685">&#34;yPos&#34;</span>, playerState.yPos },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>                                 {<span style="color:#48b685">&#34;health&#34;</span>, playerState.health } };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span>        data <span style="color:#5bc4bf">=</span> j.dump();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">16</span>}}
</code></pre></div>

<p>Here we have to create a template specialization of the asionet::message::Encoder<PlayerState> object.
The call operator takes a PlayerState reference as input and expects the data reference to be assigned to the byte string that should be transmitted over the network.</p>

<p>Since we can now send PlayerState objects, we cover the server side next.
Therefore, we have to specialize the asionet::message::Decoder<PlayerState> struct to retrieve the PlayerState object from a buffer object.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span><span style="color:#815ba4">namespace</span> asionet { <span style="color:#815ba4">namespace</span> message {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#815ba4">template</span><span style="color:#5bc4bf">&lt;&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span><span style="color:#815ba4">struct</span> Decoder<span style="color:#5bc4bf">&lt;</span>PlayerState<span style="color:#5bc4bf">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>    <span style="color:#815ba4">template</span><span style="color:#5bc4bf">&lt;</span><span style="color:#815ba4">typename</span> ConstBuffer<span style="color:#5bc4bf">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>    <span style="color:#fec418">void</span> <span style="color:#815ba4">operator</span>()(<span style="color:#815ba4">const</span> ConstBuffer <span style="color:#5bc4bf">&amp;</span> buffer, PlayerState <span style="color:#5bc4bf">&amp;</span> playerState) <span style="color:#815ba4">const</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>         <span style="color:#815ba4">auto</span> j <span style="color:#5bc4bf">=</span> nlohmann<span style="color:#5bc4bf">::</span>json<span style="color:#5bc4bf">::</span>parse(buffer.begin(), buffer.end());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>         playerState <span style="color:#5bc4bf">=</span> PlayerState{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>             j.at(<span style="color:#48b685">&#34;name&#34;</span>).get<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span>(),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span>             j.at(<span style="color:#48b685">&#34;xPos&#34;</span>).get<span style="color:#5bc4bf">&lt;</span><span style="color:#fec418">float</span><span style="color:#5bc4bf">&gt;</span>(),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span>             j.at(<span style="color:#48b685">&#34;yPos&#34;</span>).get<span style="color:#5bc4bf">&lt;</span><span style="color:#fec418">float</span><span style="color:#5bc4bf">&gt;</span>(),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span>             j.at(<span style="color:#48b685">&#34;health&#34;</span>).get<span style="color:#5bc4bf">&lt;</span><span style="color:#fec418">float</span><span style="color:#5bc4bf">&gt;</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span>         };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">16</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">17</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">19</span>}}
</code></pre></div>

<p>Note that we have to define the call operator which takes a template argument and the message to be decoded.
So what exactly is a ConstBuffer?
Since it&rsquo;s a template argument, a ConstBuffer is not an actual class but instead represents an abstract buffer interface.
This interface provides four methods:</p>

<ul>
<li>a <strong>size()</strong> function, returning the number of bytes in the buffer</li>
<li>a <strong>[]-operator</strong> returning a data byte as a char by index</li>
<li>a <strong>begin()</strong> function to get an iterator to the beginning of the buffer</li>
<li>a <strong>end()</strong> function to get an iterator to the end of the buffer</li>
</ul>

<p>By using this abstraction, asionet may internally use the most suitable buffer representation for a specific operation.</p>

<p>Finally, we can set up the UDP receiver as follows:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>DatagramReceiver<span style="color:#5bc4bf">&lt;</span>PlayerState<span style="color:#5bc4bf">&gt;</span> receiver{context, <span style="color:#f99b15">4242</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>receiver.asyncReceive(<span style="color:#f99b15">1</span>s, [](<span style="color:#815ba4">const</span> <span style="color:#815ba4">auto</span> <span style="color:#5bc4bf">&amp;</span> error, 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>                             <span style="color:#815ba4">auto</span> <span style="color:#5bc4bf">&amp;</span> playerState,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>                             <span style="color:#815ba4">auto</span> <span style="color:#5bc4bf">&amp;</span> senderEndpoint) 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>    <span style="color:#815ba4">if</span> (error) <span style="color:#815ba4">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>    std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;player: &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> playerState.name <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span>; 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span>});
</code></pre></div>

<h2 id="services">Services</h2>

<p>A common network pattern consists of sending a request to a server which reacts by sending a response back to the client.
This happens in http for instance.
Using asionet, it&rsquo;s easy to implement this pattern.</p>

<p>Assume that we want to create a server which delivers chat messages based on a query.
The query consists of two user-IDs defining the chat and the number of most recent messages that should be delivered.
Let&rsquo;s create some classes to model this scenario.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span><span style="color:#815ba4">struct</span> Query
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span>    <span style="color:#fec418">unsigned</span> <span style="color:#fec418">long</span> user1;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span>    <span style="color:#fec418">unsigned</span> <span style="color:#fec418">long</span> user2;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>    <span style="color:#fec418">unsigned</span> <span style="color:#fec418">int</span> numRequestedMessages;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span><span style="color:#815ba4">struct</span> ChatMessage
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>    <span style="color:#fec418">unsigned</span> <span style="color:#fec418">long</span> author;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>    std<span style="color:#5bc4bf">::</span>string content;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span><span style="color:#815ba4">struct</span> Response
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">16</span>    std<span style="color:#5bc4bf">::</span>vector<span style="color:#5bc4bf">&lt;</span>ChatMessage<span style="color:#5bc4bf">&gt;</span> messages;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">17</span>};
</code></pre></div>

<p>Next, we have to specialize the Encoder/Decoder classes for the Query and Response types.
Since this works exactly as shown above using the PlayerState class, we just jump over that.</p>

<p>Now, we have to create a service description:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span><span style="color:#815ba4">struct</span> ChatService
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>    <span style="color:#815ba4">using</span> RequestMessage <span style="color:#5bc4bf">=</span> Query;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>    <span style="color:#815ba4">using</span> ResponseMessage <span style="color:#5bc4bf">=</span> Response;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>}
</code></pre></div>

<p>To create a server which receives incoming requests:</p>

<p><div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>ServiceServer<span style="color:#5bc4bf">&lt;</span>ChatService<span style="color:#5bc4bf">&gt;</span> server{context, <span style="color:#f99b15">4242</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>server.advertiseService([](<span style="color:#815ba4">const</span> boost<span style="color:#5bc4bf">::</span>asio<span style="color:#5bc4bf">::</span>ip<span style="color:#5bc4bf">::</span>tcp<span style="color:#5bc4bf">::</span>endpoint <span style="color:#5bc4bf">&amp;</span> senderEndpoint, 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>                           Query <span style="color:#5bc4bf">&amp;</span> query,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>                           Response <span style="color:#5bc4bf">&amp;</span> response) 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>    std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;Requesting &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> query<span style="color:#5bc4bf">-&gt;</span>numRequestedMessages <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34; messages</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>    response <span style="color:#5bc4bf">=</span> <span style="color:#776e71">/* create your response */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span>});
</code></pre></div>
That&rsquo;s it. Simple, right?</p>

<p>Finally, calling the server on the client side looks like this:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>ServiceClient<span style="color:#5bc4bf">&lt;</span>ChatService<span style="color:#5bc4bf">&gt;</span> client{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>client.asyncCall(
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>    Query{<span style="color:#f99b15">10</span>, <span style="color:#f99b15">12</span>, <span style="color:#f99b15">50</span>}, <span style="color:#48b685">&#34;mychatserver.com&#34;</span>, <span style="color:#f99b15">4242</span>, <span style="color:#f99b15">10</span>s, 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>    [](<span style="color:#815ba4">const</span> asionet<span style="color:#5bc4bf">::</span>error<span style="color:#5bc4bf">::</span>Error <span style="color:#5bc4bf">&amp;</span> error, Response <span style="color:#5bc4bf">&amp;</span> response) 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>           <span style="color:#815ba4">if</span> (error) <span style="color:#815ba4">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>           <span style="color:#815ba4">for</span> (<span style="color:#815ba4">const</span> <span style="color:#815ba4">auto</span> <span style="color:#5bc4bf">&amp;</span> message : response.messages)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span>                std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> message.author <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34; wrote: &#34;</span> <span style="color:#5bc4bf">&lt;&lt;</span> message.content <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#48b685">&#34;</span><span style="color:#f99b15">\n</span><span style="color:#48b685">&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">9</span>    });
</code></pre></div>

<h2 id="ensuring-thread-safety">Ensuring thread-safety</h2>

<p>An important advantage of asynchronous programming is that it is easier to write thread-safe code.
Imagine all asynchronous handlers are invoked from a single thread.
Then there&rsquo;s no need for explicit locking of shared state between the handlers since everything is running in sequence (not concurrently).</p>

<p>However, running only a single thread may not be an option as we want to benefit from being able to run things in parallel.
Therefore, we can wrap handlers inside a <strong>WorkSerializer</strong> object which guarantees that handlers that are wrapped inside the WorkSerializer are executed in sequence.
In fact WorkSerializer just inherits from boost::asio::io_context::strand and can be used in exactly the same manner.</p>

<p>Let&rsquo;s consider this example:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span><span style="color:#776e71">// Create 4 threads that are concurrently dispatching handlers from the context object.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>WorkerPool workers{context, <span style="color:#f99b15">4</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span>std<span style="color:#5bc4bf">::</span>size_t counter <span style="color:#5bc4bf">=</span> <span style="color:#f99b15">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span><span style="color:#815ba4">for</span> (std<span style="color:#5bc4bf">::</span>size_t i <span style="color:#5bc4bf">=</span> <span style="color:#f99b15">0</span>; i <span style="color:#5bc4bf">&lt;</span> <span style="color:#f99b15">1000000</span>; <span style="color:#5bc4bf">++</span>i)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>    <span style="color:#776e71">// Post a handler that increments the counter.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span><span style="color:#776e71"></span>    context.post([<span style="color:#5bc4bf">&amp;</span>] { counter<span style="color:#5bc4bf">++</span>; });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>sleep(<span style="color:#776e71">/* long enough */</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> counter;
</code></pre></div>

<p>If you are familiar with concurrency problems, you are not surprised that the outcome is very likely NOT 1000000.
We can either fix this by making counter atomic or we could employ a WorkSerializer:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span><span style="color:#776e71">// Create 4 threads that are concurrently dispatching handlers from the context object.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>WorkerPool workers{context, <span style="color:#f99b15">4</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span>asionet<span style="color:#5bc4bf">::</span>WorkSerializer{context} serializer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>std<span style="color:#5bc4bf">::</span>size_t counter <span style="color:#5bc4bf">=</span> <span style="color:#f99b15">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span><span style="color:#815ba4">for</span> (std<span style="color:#5bc4bf">::</span>size_t i <span style="color:#5bc4bf">=</span> <span style="color:#f99b15">0</span>; i <span style="color:#5bc4bf">&lt;</span> <span style="color:#f99b15">1000000</span>; <span style="color:#5bc4bf">++</span>i)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span>    <span style="color:#776e71">// Post a handler that increments the counter.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span><span style="color:#776e71"></span>    <span style="color:#776e71">// Now the handler is wrapped by the WorkSerializer.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span><span style="color:#776e71"></span>    context.post(serializer([<span style="color:#5bc4bf">&amp;</span>] { counter<span style="color:#5bc4bf">++</span>; }));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>    <span style="color:#776e71">// Alternatively, use:
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span><span style="color:#776e71"></span>    <span style="color:#776e71">// serializer.post([&amp;] { counter++; });
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span><span style="color:#776e71"></span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span>sleep(<span style="color:#776e71">/* long enough */</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span>std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> counter;
</code></pre></div>

<p>We just use the WorkSerializer&rsquo;s call operator by taking the handler as input and the output should be 1000000 now.
So whenever you want your handlers to not run concurrently, just wrap them inside the SAME WorkSerializer object.</p>

<p>&hellip; and of course, in this particular example, there&rsquo;s nothing else that is executed so we could have used only a single worker instead to make it thread-safe.
But imagine you would also have other asynchronous operations running next to those which increment the counter.
Then, all other handlers would still be running concurrently if they are not wrapped inside a WorkSerializer.</p>

<p>And finally, if you have two WorkSerializer objects s1 and s2, they don&rsquo;t care about each other meaning that handlers wrapped inside s1 are running concurrently to handlers wrapped inside s2.</p>

<h2 id="lifetime-management">Lifetime management</h2>

<p>We silently ignored the dangerous dangling references problem in the code snippets above which can be easily overlooked.
The problem with running objects in handlers is that by the time a handler is executed, its containing objects could be already destructed.</p>

<p>This is made clear by the following example:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>asionet<span style="color:#5bc4bf">::</span>Worker worker{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>    std<span style="color:#5bc4bf">::</span>string text <span style="color:#5bc4bf">=</span> <span style="color:#48b685">&#34;This goes out of scope!&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>    context.post([<span style="color:#5bc4bf">&amp;</span>] { std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> text; });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">9</span><span style="color:#776e71">// Do something else...
</span></code></pre></div>

<p>Here, &lsquo;text&rsquo; could be already destructed by the time the posted handler executes since this happens on a different thread.
When accessing an invalid reference, the behavior is undefined.
Those types of bugs can be extremely hard to debug.
Therefore, we need some coding practice to systematically avoid this issue.</p>

<p>A good solution to the example above is to use a shared_ptr and pass that inside the lambda capture of the handler.</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>asionet<span style="color:#5bc4bf">::</span>Worker worker{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>    <span style="color:#815ba4">auto</span> text <span style="color:#5bc4bf">=</span> std<span style="color:#5bc4bf">::</span>make_shared<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span>(<span style="color:#48b685">&#34;I don&#39;t mind going out of scope!&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>    context.post([text] { std<span style="color:#5bc4bf">::</span>cout <span style="color:#5bc4bf">&lt;&lt;</span> <span style="color:#5bc4bf">*</span>text; });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">9</span><span style="color:#776e71">// Do something else...
</span></code></pre></div>

<p>However, it can be tedious and of bad performance to make every object a shared_ptr.
Therefore, we could also use the shared_from_this pattern:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span><span style="color:#815ba4">class</span><span style="color:#ef6155"> </span><span style="color:#fec418">ComplexObject</span> <span style="color:#5bc4bf">:</span> <span style="color:#815ba4">public</span> std<span style="color:#5bc4bf">::</span>enable_shared_from_this<span style="color:#5bc4bf">&lt;</span>ComplexObject<span style="color:#5bc4bf">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span><span style="color:#815ba4">public</span><span style="color:#5bc4bf">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span>    ComplexObject(asionet<span style="color:#5bc4bf">::</span>Context <span style="color:#5bc4bf">&amp;</span> context)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>        <span style="color:#5bc4bf">:</span> context(context), sender(context), receier(context, <span style="color:#f99b15">4242</span>) {}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>    <span style="color:#fec418">void</span> run()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>        <span style="color:#776e71">// Get a shared_ptr of &#39;this&#39;.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span><span style="color:#776e71"></span>        <span style="color:#815ba4">auto</span> self <span style="color:#5bc4bf">=</span> shared_from_this();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>        <span style="color:#776e71">// Pass self inside the capture.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">12</span><span style="color:#776e71"></span>        receiver.receive(<span style="color:#f99b15">10</span>s, [self] { <span style="color:#776e71">/* Safe! */</span> });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">15</span><span style="color:#815ba4">private</span><span style="color:#5bc4bf">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">16</span>    asionet<span style="color:#5bc4bf">::</span>DatagramSender<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span> sender;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">17</span>    asionet<span style="color:#5bc4bf">::</span>DatagramReceiver<span style="color:#5bc4bf">&lt;</span>std<span style="color:#5bc4bf">::</span>string<span style="color:#5bc4bf">&gt;</span> receiver;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">18</span>    <span style="color:#776e71">// more state ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">19</span><span style="color:#776e71"></span>};
</code></pre></div>

<p>When using ComplexObject, you have to instantiate it in a shared_ptr:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span><span style="color:#815ba4">auto</span> complexObject <span style="color:#5bc4bf">=</span> std<span style="color:#5bc4bf">::</span>make_shared<span style="color:#5bc4bf">&lt;</span>ComplexObject<span style="color:#5bc4bf">&gt;</span>(context);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>complexObject<span style="color:#5bc4bf">-&gt;</span>run();
</code></pre></div>

<p>Even if complexObject leaves its scope, any handlers invoked inside run() which capture the self pointer will not suffer from the dangling references problem.</p>

<h2 id="waiting">Waiting</h2>

<p>Sometimes you want to wait for one or more events to complete.
Consider the following:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>asionet<span style="color:#5bc4bf">::</span>WorkerPool workers{context, <span style="color:#f99b15">4</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>context.post([] { <span style="color:#776e71">/* Operation 1 */</span> });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>context.post([] { <span style="color:#776e71">/* Operation 2 */</span> });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span>context.post([] { <span style="color:#776e71">/* Operation 3 */</span> });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">8</span><span style="color:#776e71">// Objective: wait until all operation 1, 2 and 3 are done.
</span></code></pre></div>

<p>Of course, we could mess around with atomic booleans or mutexes again but if your program gets more complex, we want something more elegant.
asionet provides the <strong>Waiter</strong> and <strong>Waitable</strong> classes for this purpose:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 1</span>asionet<span style="color:#5bc4bf">::</span>Context context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 2</span>asionet<span style="color:#5bc4bf">::</span>WorkerPool workers{context, <span style="color:#f99b15">4</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 4</span>asionet<span style="color:#5bc4bf">::</span>Waiter{context} w;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 5</span>asionet<span style="color:#5bc4bf">::</span>Waitable w1{w}, w2{w}, w3{w};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 7</span>context.post(w1([] { <span style="color:#776e71">/* Operation 1 */</span> }));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 8</span>context.post(w2([] { <span style="color:#776e71">/* Operation 2 */</span> }));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d"> 9</span>context.post(w3([] { <span style="color:#776e71">/* Operation 3 */</span> }));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">11</span>w.await(w1 <span style="color:#5bc4bf">&amp;&amp;</span> w2 <span style="color:#5bc4bf">&amp;&amp;</span> w3);
</code></pre></div>

<p>Just like the WorkSerializer object, a Waitable wraps its corresponding handler and notifies its Waiter object when the handler finishes execution.
The Waiter object can then await an expression of Waitable objects.
In this case, we want to wait until all Waitable objects are ready which is represented by the chain of &amp;&amp;-operators.
Instead, we could also wait until any handler finishes execution which would be done with:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>w.await(w1 <span style="color:#5bc4bf">||</span> w2 <span style="color:#5bc4bf">||</span> w3);
</code></pre></div>

<p>Or we could say that at least two of them should be ready:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>w.await((w1 <span style="color:#5bc4bf">&amp;&amp;</span> w2) <span style="color:#5bc4bf">||</span> (w1 <span style="color:#5bc4bf">&amp;&amp;</span> w3) <span style="color:#5bc4bf">||</span> (w2 <span style="color:#5bc4bf">&amp;&amp;</span> w3));
</code></pre></div>

<p>You can also set the state of a Waitable object directly:
<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>w1.setReady();
</code></pre></div></p>

<p>If you want to reuse the waitable objects, you have to set their state to waiting again:
<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>w.await(w1 <span style="color:#5bc4bf">&amp;&amp;</span> w2 <span style="color:#5bc4bf">&amp;&amp;</span> w3);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span><span style="color:#776e71">// Reset states.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span><span style="color:#776e71"></span>w1.setWaiting();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>w2.setWaiting();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>w3.setWaiting();
</code></pre></div></p>

<h2 id="compatibility-with-boost-asio">Compatibility with boost::asio</h2>

<p>As already mentioned, asionet was designed to be seamlessly usable with existing boost::asio code.
For example, we can send and receive messages with boost::asio::ip::tcp::socket objects directly without having to use the ServiceServer or ServiceClient object:</p>

<div class="highlight"><pre style="color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">1</span>asionet<span style="color:#5bc4bf">::</span>Context <span style="color:#5bc4bf">&amp;</span> context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">2</span>boost<span style="color:#5bc4bf">::</span>asio<span style="color:#5bc4bf">::</span>ip<span style="color:#5bc4bf">::</span>tcp<span style="color:#5bc4bf">::</span>socket socket{context};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">3</span>boost<span style="color:#5bc4bf">::</span>asio<span style="color:#5bc4bf">::</span>ip<span style="color:#5bc4bf">::</span>tcp<span style="color:#5bc4bf">::</span>endpoint endpoint{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">4</span>    boost<span style="color:#5bc4bf">::</span>asio<span style="color:#5bc4bf">::</span>ip<span style="color:#5bc4bf">::</span>address<span style="color:#5bc4bf">::</span>from_string(<span style="color:#48b685">&#34;1.2.3.4&#34;</span>), <span style="color:#f99b15">4242</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">5</span>socket.connect(endpoint);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">6</span><span style="color:#776e71">// Send the message over the socket.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#73746d">7</span><span style="color:#776e71"></span>asionet<span style="color:#5bc4bf">::</span>message<span style="color:#5bc4bf">::</span>asyncSend(socket, PlayerState{<span style="color:#48b685">&#34;name&#34;</span>, <span style="color:#f99b15">1.f</span>, <span style="color:#f99b15">0.f</span>, <span style="color:#f99b15">0.5f</span>}, <span style="color:#f99b15">1</span>s);
</code></pre></div>

              

        </div>
    </article>

    <hr>
    
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-md-10 offset-md-1">
                  <ul class="list-inline text-center">
                    
                      <li class="list-inline-item">
                        <a href="mailto:philipp.badenhoop@hellocodeblog.com">
                          <span class="fa-stack fa-lg">
                            <i class="fa fa-circle fa-stack-2x"></i>
                            <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                          </span>
                        </a>
                      </li>
                    
                    
                    
                    <li class="list-inline-item">
                      <a href="https://twitter.com/PBadenhoop">
                        <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                        </span>
                      </a>
                    </li>
                    
                    <li class="list-inline-item">
                      <a href="https://github.com/Badenhoop">
                        <span class="fa-stack fa-lg">
                          <i class="fa fa-circle fa-stack-2x"></i>
                          <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                        </span>
                      </a>
                    </li>
                    
                    
                  </ul>
                  <p><a href="https://hellocodeblog.com/cookie-preferences" id="changeCookiePreferences" class="text-muted">Cookie Preferences</a></p>
                  <p class="copyright text-muted">© 2019 by Philipp Badenhoop. All Rights Reserved.</p>
                </div>
            </div>
        </div>
    </footer>

    
    <script src="https://hellocodeblog.com/js/jquery.min.js"></script>

    
    <script src="https://hellocodeblog.com/js/bootstrap.min.js"></script>

    
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

    
    <script src="https://hellocodeblog.com/js/hello-code-blog.js"></script>

    
    <script>
      
      COOKIE_CONSENT = '\x3cdiv class=\x22cookie-consent outer d-flex justify-content-center align-items-center\x22\x3e\n  \x3cdiv class=\x22inner\x22\x3e\n    \x3ch1\x3eWe use cookies\x3c\/h1\x3e\n    \x3cp\x3eWe use cookies to analyze our website traffic. By browsing our website, you consent to our use of cookies. For more informations, please read our \x3ca href=\x22https:\/\/hellocodeblog.com\/privacy-policy\x22 target=\x22_blank\x22\x3eprivacy policy\x3c\/a\x3e\x3c\/p\x3e\n    \x3cul class=\x22list-inline\x22\x3e\n      \x3cli class=\x22list-inline-item\x22\x3e\x3cbutton class=\x22btn btn-warning\x22 onclick=\x22enableCookieUsage();hideCookieConsent();\x22\x3eAccept\x3c\/button\x3e\x3c\/li\x3e\n      \x3cli class=\x22list-inline-item\x22\x3e\x3cbutton class=\x22btn btn-secondary\x22 onclick=\x22disableCookieUsage();hideCookieConsent();\x22\x3eCancel\x3c\/button\x3e\x3c\/li\x3e\n    \x3c\/ul\x3e\n  \x3c\/div\x3e\n\x3c\/div\x3e'
    </script>
    <script src="https://hellocodeblog.com/js/cookie.js"></script>

</body>

</html>

